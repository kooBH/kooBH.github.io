---
layout : default
title:  "tips"
date:   2019-02-08 17:30:00
---
v5
[home](/)



## INDEX<a name="index"></a>

+ [git commit message 수정](#t1)
+ [git 로컬 파일 강제로 덮어 씌우기](#t2)
+ [git 수정한 파일 되돌리기](#t3)
+ [sed 파일에서 찾아 바꾸기](#t4)
+ [sox raw 에서 wav 로](#t5)
+ [make 멀티 프로세서 빌드](#t6)
+ [c 스톱와치](#t7)
+ [c++ 스톱와치](#t7)


### [git commit message 수정](#index)<a name="t1"></a>

```
git commit --amend
```

### [git 로컬 파일 강제로 덮어 씌우기](#index)<a name="t2"></a>

```
git fetch --all
git reset --hard origin/master
git pull origin master
```


### [git 수정한 파일 되돌리기](#index)<a name="t3"></a>

```
git checkout --<file>
```


### [sed 파일에서 찾아 바꾸기](#index)<a name="t4"></a>

```
sed -i 's/<from>/<to>/g' <file>
```

### [sox raw에서  wav 로](#index)<a name="t5"></a>


```
sox -t raw -r <샘플레이트> -b 16 -c <채널> -L -e signed-integer <*.raw> <*.wav>
```

### [make 멀티 프로세서 빌드](#index)<a name="t6"></a>

```
make -j <프로세서 수>
```

### [C 스톱와치](#index)<a name="t7"></a>

아래 코드는 그냥 마이크로 초 단위로 리턴함, 다른 단위로 
수정 가능  
  
```C

#include <time.h>

#if __linux__
long long stopwatch(int flag);
#elif _WIN32
LARGE_INTEGER get_filetime_offset();
int clock_gettime(struct timeval *tv);
long long stopwatch(int flag);
#endif

/* return micro sec of currnet time, used for srand()*/
long long get_micro_sec();
#endif

#if __linux__
long long stopwatch(int flag) {
  enum clock_unit { nano = 0, micro, milli, sec } unit;

  const long long NANOS = 1000000000LL;
  static struct timespec startTS, endTS;
  static long long diff = 0;

  /*
          nano, micro, milli, sec
  */
  unit = micro;

  // start
  if (flag == 0) {
    diff = 0;
    if (-1 == clock_gettime(CLOCK_MONOTONIC, &startTS))
      printf("Failed to call clock_gettime\n");
  }
  // end
  else if (flag == 1) {
    if (-1 == clock_gettime(CLOCK_MONOTONIC, &endTS))
      printf("Failed to call clock_gettime\n");
    diff = NANOS * (endTS.tv_sec - startTS.tv_sec) +
           (endTS.tv_nsec - startTS.tv_nsec);

    // switch (unit) {
    //   case nano:
    //     printf("%lld nano sec\n", diff);
    //     break;
    //   case micro:
    //     printf("%lld micro seconds\n", diff / 1000);
    //     break;
    //   case sec:
    //     printf("%lld sec\n", diff / 1000000000);
    //     break;
    //   default:
    //     printf("%lld milli sec\n", diff / 100000);
    //     break;
    //    }
  } else {
    printf("wrong flag | 0 : start, 1 : end\n");
  }
  return diff / 1000;
}
#else

LARGE_INTEGER get_filetime_offset() {
  SYSTEMTIME s;
  FILETIME f;
  LARGE_INTEGER t;
  s.wYear = 1970;
  s.wMonth = 1;
  s.wDay = 1;
  s.wHour = 0;
  s.wMinute = 0;
  s.wSecond = 0;
  s.wMilliseconds = 0;
  SystemTimeToFileTime(&s, &f);
  t.QuadPart = f.dwHighDateTime;
  t.QuadPart <<= 32;
  t.QuadPart |= f.dwLowDateTime;
  return (t);
}

int clock_gettime(struct timeval *tv) {
  LARGE_INTEGER t;
  FILETIME f;
  double microseconds;
  static LARGE_INTEGER offset;
  static double frequencyToMicroseconds;
  static int initialized = 0;
  static BOOL usePerformanceCounter = 0;
  if (!initialized) {
    LARGE_INTEGER performanceFrequency;
    initialized = 1;
    usePerformanceCounter = QueryPerformanceFrequency(&performanceFrequency);
    if (usePerformanceCounter) {
      QueryPerformanceCounter(&offset);
      frequencyToMicroseconds =
          (double)performanceFrequency.QuadPart / 1000000.;
    } else {
      offset = get_filetime_offset();
      frequencyToMicroseconds = 10.;
    }
  }
  if (usePerformanceCounter)
    QueryPerformanceCounter(&t);
  else {
    GetSystemTimeAsFileTime(&f);
    t.QuadPart = f.dwHighDateTime;
    t.QuadPart <<= 32;
    t.QuadPart |= f.dwLowDateTime;
  }
  t.QuadPart -= offset.QuadPart;
  microseconds = (double)t.QuadPart / frequencyToMicroseconds;
  t.QuadPart = microseconds;
  tv->tv_sec = t.QuadPart / 1000000;
  tv->tv_usec = t.QuadPart % 1000000;
  return (0);
}

long long stopwatch(int flag) {
  static struct timeval startTV, endTV;
  static long long diff;
  const long long MICRO = 1000000LL;

  if (flag == 0)
    clock_gettime(&startTV);
  else {
    clock_gettime(&endTV);
    diff = MICRO * (endTV.tv_sec - startTV.tv_sec) +
           (endTV.tv_usec - startTV.tv_usec);
    // printf("%lld micro seconds\n", diff);
  }
  return diff;
}
#endif

long long get_micro_sec() {
  struct timeval utime;
#if OS_UNIX
  clock_gettime(CLOCK_MONOTONIC, &utime);
#elif OS_WIN
  clock_gettime(&utime);
#endif
  return utime.tv_usec;
}

```


### [C++ 스톱와치](#index)<a name="t8"></a>




```C++
#include <chrono>

auto start = std::chrono::high_resolution_clock::now();
auto elapsed = std::chrono::high_resolution_clock::now() - start;
long long microseconds = std::chrono::duration_cast<std::chrono::microseconds>(elapsed).count();
std::cout<<"Elapsed Time : "<<microseconds<<"("<<(double)microseconds/1000000<<")\n";


```


